@namespace TelegramPanel.Web.Components.Dialogs
@inject AccountManagementService AccountManagement
@inject TelegramPanel.Core.Services.Telegram.AccountTelegramToolsService AccountTelegramTools
@inject TelegramPanel.Core.Services.AccountRiskService RiskService
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@using TelegramPanel.Data.Entities

<MudDialog>
    <DialogContent>
        <MudStack Spacing="2">
            <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Dense="true">
                将对选中的账号批量修改昵称。支持两种模式：单个“批量昵称”（可自动追加手机号后 4 位），或“昵称列表”（按行轮询分配）。
            </MudAlert>

            <MudText Typo="Typo.subtitle2">账号数量：@accounts.Count</MudText>

            <MudTextField @bind-Value="baseNickname" Label="批量昵称" Variant="Variant.Outlined" Required="true"
                          HelperText="单昵称模式：例如“测试号”（将生成：测试号1234 / 测试号5678 ...）。若填写了“昵称列表”，则优先使用昵称列表。" />
            <MudSwitch @bind-Value="appendPhoneLast4" Label="自动追加手机号后 4 位（单昵称模式）" Color="Color.Primary" />

            <MudTextField @bind-Value="nicknameLines" Label="昵称列表（换行分隔）" Variant="Variant.Outlined" Lines="6"
                          HelperText="每行一个昵称；会按顺序依次分配给已选账号；昵称用完后从头开始轮询。" />
            <MudSwitch @bind-Value="appendPhoneLast4WhenDuplicate" Label="昵称重复时追加手机号后 4 位（昵称列表模式）" Color="Color.Primary" />
            <MudText Typo="Typo.caption" Class="mud-text-secondary">
                例如：昵称列表只有 1 行或轮询后重复时，为避免重复昵称可追加手机号后 4 位。
            </MudText>

            @if (running || results.Count > 0)
            {
                <MudDivider Class="my-2" />

                <MudStack direction="Row" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Typo="Typo.body2">进度：@processed / @accounts.Count</MudText>
                    <MudText Typo="Typo.body2" Color="Color.Success">成功：@success</MudText>
                    <MudText Typo="Typo.body2" Color="Color.Error">失败：@failed</MudText>
                    @if (running)
                    {
                        <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                    }
                </MudStack>

                <MudTable Items="@results" Dense="true" Hover="true" Breakpoint="Breakpoint.Sm">
                    <HeaderContent>
                        <MudTh>账号</MudTh>
                        <MudTh>新昵称</MudTh>
                        <MudTh>结果</MudTh>
                        <MudTh>原因</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="账号">@context.Phone</MudTd>
                        <MudTd DataLabel="新昵称">@context.NewNickname</MudTd>
                        <MudTd DataLabel="结果">
                            <MudChip T="string" Size="Size.Small" Color="@(context.Success ? Color.Success : Color.Error)">
                                @(context.Success ? "成功" : "失败")
                            </MudChip>
                        </MudTd>
                        <MudTd DataLabel="原因">@((context.Error ?? "").Trim())</MudTd>
                    </RowTemplate>
                </MudTable>
            }
        </MudStack>
    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Text" Color="Color.Default" OnClick="Cancel" Disabled="@running">关闭</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="Start" Disabled="@running">
            @if (running)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <span>执行中...</span>
            }
            else
            {
                <span>开始修改</span>
            }
        </MudButton>
    </DialogActions>
</MudDialog>

@code
{
    [CascadingParameter] private MudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public IReadOnlyList<int> AccountIds { get; set; } = Array.Empty<int>();

    private List<Account> accounts = new();

    private string baseNickname = "";
    private bool appendPhoneLast4 = true;
    private string nicknameLines = "";
    private bool appendPhoneLast4WhenDuplicate = true;

    private bool running;
    private int processed;
    private int success;
    private int failed;
    private readonly List<ResultRow> results = new();

    protected override async Task OnInitializedAsync()
    {
        var ids = AccountIds?.Distinct().Where(x => x > 0).ToList() ?? new List<int>();
        if (ids.Count == 0)
            return;

        var all = await AccountManagement.GetAllAccountsAsync();
        accounts = all.Where(a => ids.Contains(a.Id)).OrderBy(a => a.Id).ToList();
    }

    private async Task Start()
    {
        if (running)
            return;

        if (accounts.Count == 0)
        {
            Snackbar.Add("未选择账号", Severity.Warning);
            return;
        }

        var nicknameList = ParseNicknameLines(nicknameLines);
        var useList = nicknameList.Count > 0;

        if (!useList && string.IsNullOrWhiteSpace(baseNickname))
        {
            Snackbar.Add("批量昵称不能为空", Severity.Warning);
            return;
        }

        // 批量风控检查：修改昵称是敏感操作
        var batchCheck = RiskService.CheckBatchAccounts(accounts);
        if (batchCheck.HasRiskyAccounts)
        {
            var parameters = new DialogParameters
            {
                ["Message"] = $"检测到 {batchCheck.RiskyCount} 个风险账号",
                ["DetailedMessage"] = batchCheck.GetRiskySummary(),
                ["ShowRecommendations"] = true,
                ["ShowExcludeOption"] = true,
                ["RiskyAccounts"] = batchCheck.RiskyAccounts.ToList()
            };
            var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Large };
            var dialog = DialogService.Show<TelegramPanel.Web.Components.Dialogs.RiskWarningDialog>("批量操作风控警告", parameters, options);
            var result = await dialog.Result;

            if (result.Canceled)
                return; // 用户取消操作

            if (result.Data is TelegramPanel.Core.Services.RiskWarningAction action && action == TelegramPanel.Core.Services.RiskWarningAction.ExcludeRisky)
            {
                // 排除风险账号后继续
                accounts = batchCheck.SafeAccounts.ToList();
                if (accounts.Count == 0)
                {
                    Snackbar.Add("排除风险账号后无剩余账号", Severity.Info);
                    return;
                }
            }
            // else: 用户选择继续所有账号
        }

        bool? confirm = await DialogService.ShowMessageBox(
            "确认修改",
            $"将对 {accounts.Count} 个账号批量修改昵称。是否继续？",
            yesText: "继续", cancelText: "取消");

        if (confirm != true)
            return;

        running = true;
        processed = 0;
        success = 0;
        failed = 0;
        results.Clear();

        try
        {
            var baseUsedCount = new Dictionary<string, int>(StringComparer.Ordinal);
            foreach (var a in accounts)
            {
                var baseName = useList ? nicknameList[processed % nicknameList.Count] : baseNickname;

                var needAppend = appendPhoneLast4;
                if (useList)
                {
                    baseName = (baseName ?? string.Empty).Trim();
                    baseUsedCount.TryGetValue(baseName, out var used);
                    baseUsedCount[baseName] = used + 1;
                    needAppend = appendPhoneLast4WhenDuplicate && used > 0;
                }

                var newNickname = BuildNickname(baseName, a.Phone, needAppend);

                var (ok, err) = await AccountTelegramTools.UpdateUserProfileAsync(
                    accountId: a.Id,
                    nickname: newNickname,
                    bio: null,
                    cancellationToken: CancellationToken.None);

                processed++;
                if (ok) success++; else failed++;
                results.Add(new ResultRow(a.Phone, newNickname, ok, err));

                if (ok)
                {
                    a.Nickname = newNickname;
                    await AccountManagement.UpdateAccountAsync(a);
                }

                StateHasChanged();
            }

            Snackbar.Add($"昵称批量修改完成：成功 {success}/{accounts.Count}，失败 {failed}/{accounts.Count}", failed == 0 ? Severity.Success : Severity.Warning);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"执行失败：{ex.Message}", Severity.Error);
        }
        finally
        {
            running = false;
        }
    }

    private static string BuildNickname(string baseName, string phone, bool appendLast4)
    {
        var name = (baseName ?? string.Empty).Trim();
        if (!appendLast4)
            return name;

        var digits = ExtractDigits(phone);
        if (digits.Length == 0)
            return name;

        var tail = digits.Length <= 4 ? digits : digits.Substring(digits.Length - 4);
        return $"{name}{tail}";
    }

    private static string ExtractDigits(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return string.Empty;

        var chars = new char[input.Length];
        var count = 0;
        foreach (var ch in input)
        {
            if (ch >= '0' && ch <= '9')
                chars[count++] = ch;
        }

        return count == 0 ? string.Empty : new string(chars, 0, count);
    }

    private static List<string> ParseNicknameLines(string? text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return new List<string>();

        return text
            .Split(new[] { "\r\n", "\n", "\r" }, StringSplitOptions.RemoveEmptyEntries)
            .Select(x => (x ?? string.Empty).Trim())
            .Where(x => !string.IsNullOrWhiteSpace(x))
            .ToList();
    }

    private void Cancel() => MudDialog.Close();

    private sealed record ResultRow(string Phone, string NewNickname, bool Success, string? Error);
}

