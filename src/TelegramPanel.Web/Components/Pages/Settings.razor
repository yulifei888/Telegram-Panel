@page "/settings"
@inject IConfiguration Configuration
@inject AccountManagementService AccountManagement
@inject ChannelManagementService ChannelManagement
@inject GroupManagementService GroupManagement
@inject IChannelService ChannelService
@inject IGroupService GroupService
@inject ITelegramClientPool TelegramClientPool
@inject TelegramPanel.Web.Services.DataSyncService DataSync
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IWebHostEnvironment Environment
@inject PanelTimeZoneService TimeZone
@inject NavigationManager Navigation
@inject CloudMailClient CloudMail
@using TelegramPanel.Web.Services
@using TelegramPanel.Core.Utils

<PageTitle>系统设置 - Telegram Panel</PageTitle>

<MudText Typo="Typo.h4" Class="mb-4">系统设置</MudText>

<MudGrid>
    <MudItem xs="12" md="6">
        <MudCard Class="mb-4">
            <MudCardHeader>
                <MudText Typo="Typo.h6">Telegram API 配置</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudTextField @bind-Value="apiId" Label="默认 API ID" Variant="Variant.Outlined"
                              HelperText="从 https://my.telegram.org 获取" />
                <MudTextField @bind-Value="apiHash" Label="默认 API Hash" Variant="Variant.Outlined" Class="mt-3"
                              HelperText="用于新账号登录和导入（32 位十六进制字符串）" />
                <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Dense="true" Class="mt-3">
                    <MudText Typo="Typo.body2"><strong>写入位置：</strong>@LocalConfigPath</MudText>
                    <MudText Typo="Typo.body2" Class="mt-1"><strong>文件存在：</strong>@(LocalConfigExists ? "是" : "否")</MudText>
                    <MudText Typo="Typo.body2" Class="mt-1"><strong>当前生效 ApiId：</strong>@(Configuration["Telegram:ApiId"] ?? "（未配置）")</MudText>
                </MudAlert>
            </MudCardContent>
            <MudCardActions>
                <MudButton Variant="Variant.Filled" Color="Color.Primary"
                           OnClick="@(async (MouseEventArgs _) => await SaveApiConfig())">
                    保存配置
                </MudButton>
            </MudCardActions>
        </MudCard>

        <MudCard Class="mb-4">
            <MudCardHeader>
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Typo="Typo.h6">Cloud Mail 对接</MudText>
                    <MudLink Href="https://github.com/maillab/cloud-mail" Target="_blank" Underline="Underline.Always">
                        GitHub
                    </MudLink>
                </MudStack>
            </MudCardHeader>
            <MudCardContent>
                <MudTextField @bind-Value="cloudMailBaseUrl" Label="Cloud Mail URL" Variant="Variant.Outlined"
                              HelperText="例如：https://mail.example.com（无需填写 /api）" />
                <MudTextField @bind-Value="cloudMailDomain" Label="邮箱域名" Variant="Variant.Outlined" Class="mt-3"
                              HelperText="例如：xx.com（将生成 手机号数字@xx.com）" />
                <MudTextField @bind-Value="cloudMailToken" Label="Authorization Token" Variant="Variant.Outlined" Class="mt-3"
                              HelperText="Cloud Mail 的全局 Token（生成新 Token 会使旧 Token 失效）" />

                <MudDivider Class="my-3" />
                <MudText Typo="Typo.subtitle2">生成 Token（可选）</MudText>
                <MudTextField @bind-Value="cloudMailAdminEmail" Label="管理员邮箱" Variant="Variant.Outlined" Class="mt-2" />
                <MudTextField @bind-Value="cloudMailAdminPassword" Label="管理员密码" Variant="Variant.Outlined" Class="mt-3"
                              InputType="InputType.Password" />
            </MudCardContent>
            <MudCardActions>
                <MudButton Variant="Variant.Filled" Color="Color.Primary"
                           OnClick="@(async (MouseEventArgs _) => await SaveCloudMailConfig())">
                    保存配置
                </MudButton>
                <MudButton Variant="Variant.Outlined" Color="Color.Info"
                           Disabled="@cloudMailGeneratingToken"
                           OnClick="@(async (MouseEventArgs _) => await GenerateCloudMailToken())">
                    生成并填入 Token
                </MudButton>
            </MudCardActions>
        </MudCard>
 
        <MudCard>
            <MudCardHeader>
                <MudText Typo="Typo.h6">批量操作设置</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudNumericField @bind-Value="defaultDelay" Label="默认操作间隔 (毫秒)" Variant="Variant.Outlined"
                                 Min="1000" Max="10000" HelperText="建议2000-5000ms" />
                <MudNumericField @bind-Value="maxConcurrent" Label="最大并发任务数" Variant="Variant.Outlined" Class="mt-3"
                                 Min="1" Max="10" HelperText="同时执行的任务数量" />
                <MudSwitch @bind-Value="autoRetry" Label="失败自动重试" Color="Color.Primary" Class="mt-3" />
                @if (autoRetry)
                {
                    <MudNumericField @bind-Value="maxRetries" Label="最大重试次数" Variant="Variant.Outlined" Class="mt-3"
                                     Min="1" Max="5" />
                }
            </MudCardContent>
            <MudCardActions>
                <MudButton Variant="Variant.Filled" Color="Color.Primary"
                           OnClick="@(async (MouseEventArgs _) => await SaveBatchConfig())">
                    保存配置
                </MudButton>
            </MudCardActions>
        </MudCard>

        <MudCard Class="mb-4">
            <MudCardHeader>
                <MudText Typo="Typo.h6">本地化</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudSelect @bind-Value="timeZoneId" Label="时区（用于面板显示）" Variant="Variant.Outlined" Dense="true">
                    @foreach (var item in KnownTimeZones)
                    {
                        <MudSelectItem Value="@item.Id">@item.Label</MudSelectItem>
                    }
                </MudSelect>
                <MudText Typo="Typo.caption" Class="mt-2 mud-text-secondary">
                    当前生效：@EffectiveTimeZoneHint
                </MudText>
                <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Dense="true" Class="mt-3">
                    <MudText Typo="Typo.body2">
                        本项目数据库中的时间统一按 UTC 存储；该设置仅影响面板显示的时区转换。
                    </MudText>
                </MudAlert>
            </MudCardContent>
            <MudCardActions>
                <MudButton Variant="Variant.Filled" Color="Color.Primary"
                           OnClick="@(async (MouseEventArgs _) => await SaveTimeZoneConfig())">
                    保存时区
                </MudButton>
            </MudCardActions>
        </MudCard>
    </MudItem>

    <MudItem xs="12" md="6">
        <MudCard Class="mb-4">
            <MudCardHeader>
                <MudText Typo="Typo.h6">数据同步</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Dense="true" Class="mb-3">
                    <MudText Typo="Typo.body2">
                        <strong>同步说明：</strong>将每个活跃账号“创建的频道 + 创建的群组”拉取并写入本地数据库，用于频道/群组列表展示，以及批量任务自动选择执行账号。
                        <br />
                        <strong>不包含：</strong>Telegram 状态检测（冻结/封号等）与验证码收取。
                    </MudText>
                </MudAlert>

                <MudSwitch @bind-Value="autoSync" Label="自动同步频道/群组数据（后台）" Color="Color.Primary" />
                @if (autoSync)
                {
                    <MudNumericField @bind-Value="syncInterval" Label="同步间隔 (小时)" Variant="Variant.Outlined" Class="mt-3"
                                     Min="1" Max="24" />
                }
                <MudButton Variant="Variant.Outlined" Color="Color.Primary" FullWidth="true" Class="mt-3"
                           OnClick="@(async (MouseEventArgs _) => await SaveSyncConfig())">
                    保存同步设置
                </MudButton>

                <MudDivider Class="my-4" />

                <MudText Typo="Typo.subtitle2">Bot 频道秒级更新</MudText>
                <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-2">
                    说明：开启后后台会持续轮询 Bot API（getUpdates）并应用 my_chat_member 更新，用于 Bot 被加入/撤权频道后自动出现在“Bot 频道”列表。
                </MudText>
                <MudSwitch @bind-Value="botAutoSyncEnabled" Label="自动同步 Bot 频道（后台）" Color="Color.Primary" />
                @if (botAutoSyncEnabled)
                {
                    <MudNumericField @bind-Value="botAutoSyncIntervalSeconds" Label="轮询间隔 (秒)" Variant="Variant.Outlined" Class="mt-3"
                                     Min="2" Max="60" HelperText="建议 2-10 秒；过低可能更容易触发 Telegram 限流。" />
                }
                <MudButton Variant="Variant.Outlined" Color="Color.Primary" FullWidth="true" Class="mt-3"
                           OnClick="@(async (MouseEventArgs _) => await SaveBotAutoSyncConfig())">
                    保存 Bot 自动同步设置
                </MudButton>

                <MudButton Variant="Variant.Outlined" Color="Color.Info" FullWidth="true" Class="mt-4"
                           OnClick="@(async (MouseEventArgs _) => await SyncNow())">
                    立即同步
                </MudButton>
            </MudCardContent>
        </MudCard>

        <MudCard Class="mb-4">
            <MudCardHeader>
                <MudText Typo="Typo.h6">安全</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudText Typo="Typo.body2">
                    修改后台登录密码。
                </MudText>
            </MudCardContent>
            <MudCardActions>
                <MudButton Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Password"
                           OnClick="@(async (MouseEventArgs _) => await OpenChangePassword())">
                    修改密码
                </MudButton>
            </MudCardActions>
        </MudCard>

        <MudCard Class="mb-4">
            <MudCardHeader>
                <MudText Typo="Typo.h6">日志设置</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudSwitch T="bool" @bind-Value="logEnabled" Color="Color.Primary" Class="mb-2">
                    启用日志输出
                </MudSwitch>
                <MudText Typo="Typo.caption" Color="Color.Secondary">
                    说明：关闭后会禁用 Serilog 输出（控制台/文件）。Docker 仍可能记录 stdout/stderr，建议同时在 docker-compose 配置日志滚动。
                </MudText>

                <MudSelect @bind-Value="logLevel" Label="日志级别" Variant="Variant.Outlined" Disabled="@(!logEnabled)"
                           Class="mt-3">
                    <MudSelectItem Value='@("Debug")'>Debug</MudSelectItem>
                    <MudSelectItem Value='@("Information")'>Information</MudSelectItem>
                    <MudSelectItem Value='@("Warning")'>Warning</MudSelectItem>
                    <MudSelectItem Value='@("Error")'>Error</MudSelectItem>
                </MudSelect>
                <MudNumericField @bind-Value="logRetentionDays" Label="日志保留天数" Variant="Variant.Outlined" Class="mt-3"
                                 Disabled="@(!logEnabled)"
                                 Min="1" Max="90" />
            </MudCardContent>
            <MudCardActions>
                <MudButton Variant="Variant.Filled" Color="Color.Primary"
                           OnClick="@(async (MouseEventArgs _) => await SaveLogConfig())">
                    保存配置
                </MudButton>
            </MudCardActions>
        </MudCard>

        <MudCard>
            <MudCardHeader>
                <MudText Typo="Typo.h6">系统信息</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudText Typo="Typo.body2"><strong>版本：</strong> @VersionService.Version</MudText>
                <MudText Typo="Typo.body2" Class="mt-2"><strong>运行时：</strong> .NET 8.0</MudText>
                <MudText Typo="Typo.body2" Class="mt-2"><strong>数据库：</strong> SQLite</MudText>
                <MudDivider Class="my-3" />
                <MudButton Variant="Variant.Outlined" Color="Color.Secondary" FullWidth="true"
                           StartIcon="@Icons.Material.Filled.Delete"
                           OnClick="@(async (MouseEventArgs _) => await ClearCache())">
                    清除缓存
                </MudButton>
            </MudCardContent>
        </MudCard>
    </MudItem>
</MudGrid>

@code {
    private string apiId = "";
    private string apiHash = "";
    private int defaultDelay = 2000;
    private int maxConcurrent = 3;
    private bool autoRetry = true;
    private int maxRetries = 3;
    private bool autoSync = true;
    private int syncInterval = 6;
    private bool botAutoSyncEnabled = false;
    private int botAutoSyncIntervalSeconds = 2;
    private bool logEnabled = false;
    private string logLevel = "Information";
    private int logRetentionDays = 30;
    private bool syncing = false;
    private string timeZoneId = "";
    private string cloudMailBaseUrl = "";
    private string cloudMailDomain = "";
    private string cloudMailToken = "";
    private string cloudMailAdminEmail = "";
    private string cloudMailAdminPassword = "";
    private bool cloudMailGeneratingToken = false;

    private sealed record TimeZoneChoice(string Id, string Label);

    private static readonly IReadOnlyList<TimeZoneChoice> KnownTimeZones = new List<TimeZoneChoice>
    {
        new("Asia/Shanghai", "北京时间（Asia/Shanghai）"),
        new("UTC", "UTC"),
        new("China Standard Time", "北京时间（Windows: China Standard Time）")
    };

    private string EffectiveTimeZoneHint
    {
        get
        {
            var tz = TimeZone.Current;
            var sign = tz.BaseUtcOffset >= TimeSpan.Zero ? "+" : "-";
            var offset = tz.BaseUtcOffset.Duration().ToString(@"hh\:mm");
            var now = TimeZone.Format(DateTime.UtcNow, "yyyy-MM-dd HH:mm:ss");
            return $"{tz.Id}（UTC{sign}{offset}），现在：{now}";
        }
    }

    private string LocalConfigPath => LocalConfigFile.ResolvePath(Configuration, Environment);
    private bool LocalConfigExists => System.IO.File.Exists(LocalConfigPath);

    protected override void OnInitialized()
    {
        // 从配置文件加载默认设置
        apiId = Configuration["Telegram:ApiId"] ?? "";
        apiHash = Configuration["Telegram:ApiHash"] ?? "";
        autoSync = Configuration.GetValue("Sync:AutoSyncEnabled", false);
        syncInterval = Configuration.GetValue("Sync:IntervalHours", 6);
        botAutoSyncEnabled = Configuration.GetValue("Telegram:BotAutoSyncEnabled", false);
        botAutoSyncIntervalSeconds = Configuration.GetValue("Telegram:BotAutoSyncIntervalSeconds", 2);
        logEnabled = Configuration.GetValue("Serilog:Enabled", false);
        logLevel = (Configuration["Serilog:MinimumLevel:Default"] ?? "Information").Trim();
        logRetentionDays = Configuration.GetValue("Serilog:RetainedFileCountLimit", 30);
        timeZoneId = Configuration["System:TimeZoneId"] ?? "";
        cloudMailBaseUrl = Configuration["CloudMail:BaseUrl"] ?? "";
        cloudMailDomain = Configuration["CloudMail:Domain"] ?? "";
        cloudMailToken = Configuration["CloudMail:Token"] ?? "";
    }

    private async Task SaveApiConfig()
    {
        if (!int.TryParse(apiId, out int parsedApiId) || parsedApiId <= 0)
        {
            Snackbar.Add("默认 API ID 格式错误", Severity.Error);
            return;
        }

        if (string.IsNullOrWhiteSpace(apiHash))
        {
            Snackbar.Add("默认 API Hash 不能为空", Severity.Error);
            return;
        }

        if (!TelegramApiConfigValidator.TryNormalizeApiHash(apiHash, out var normalizedApiHash, out var apiHashReason))
        {
            Snackbar.Add($"默认 API Hash 无效：{apiHashReason}", Severity.Error);
            return;
        }

        try
        {
            var localConfigPath = LocalConfigPath;
            var root = await LoadOrCreateLocalConfigAsync();
            var telegram = EnsureObject(root, "Telegram");
            telegram["ApiId"] = parsedApiId;
            telegram["ApiHash"] = normalizedApiHash;
            await SaveLocalConfigAsync(root);

            // 配置变更后清理客户端缓存，确保后续操作使用新 ApiId/ApiHash
            await TelegramClientPool.RemoveAllClientsAsync();

            string sizeHint;
            try
            {
                var fileInfo = new System.IO.FileInfo(localConfigPath);
                sizeHint = $"（{fileInfo.Length} bytes）";
            }
            catch
            {
                sizeHint = "";
            }

            Snackbar.Add($"API 配置已保存：{localConfigPath}{sizeHint}。已清理 Telegram 客户端缓存，后续操作将使用新配置。", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"保存失败：{ex.Message}（路径：{LocalConfigPath}）", Severity.Error);
        }
    }

    private async Task SaveSyncConfig()
    {
        if (autoSync && (syncInterval < 1 || syncInterval > 24))
        {
            Snackbar.Add("同步间隔范围应为 1-24 小时", Severity.Error);
            return;
        }

        try
        {
            var root = await LoadOrCreateLocalConfigAsync();
            var sync = EnsureObject(root, "Sync");
            sync["AutoSyncEnabled"] = autoSync;
            sync["IntervalHours"] = syncInterval;
            await SaveLocalConfigAsync(root);

            Snackbar.Add("同步设置已保存（重启/自动重载后生效）", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"保存失败：{ex.Message}（路径：{LocalConfigPath}）", Severity.Error);
        }
    }

    private async Task SaveCloudMailConfig()
    {
        try
        {
            var root = await LoadOrCreateLocalConfigAsync();
            var cloud = EnsureObject(root, "CloudMail");
            cloud["BaseUrl"] = (cloudMailBaseUrl ?? string.Empty).Trim();
            cloud["Domain"] = (cloudMailDomain ?? string.Empty).Trim().TrimStart('@');
            cloud["Token"] = (cloudMailToken ?? string.Empty).Trim();
            await SaveLocalConfigAsync(root);

            Snackbar.Add("Cloud Mail 配置已保存（配置热重载后生效）", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"保存失败：{ex.Message}（路径：{LocalConfigPath}）", Severity.Error);
        }
    }

    private async Task GenerateCloudMailToken()
    {
        if (cloudMailGeneratingToken)
            return;

        var baseUrl = (cloudMailBaseUrl ?? string.Empty).Trim();
        var email = (cloudMailAdminEmail ?? string.Empty).Trim();
        var password = cloudMailAdminPassword ?? string.Empty;

        if (string.IsNullOrWhiteSpace(baseUrl))
        {
            Snackbar.Add("请先填写 Cloud Mail URL", Severity.Warning);
            return;
        }

        if (string.IsNullOrWhiteSpace(email) || string.IsNullOrWhiteSpace(password))
        {
            Snackbar.Add("请填写管理员邮箱和密码", Severity.Warning);
            return;
        }

        cloudMailGeneratingToken = true;
        try
        {
            var token = await CloudMail.GenerateTokenAsync(baseUrl, email, password, CancellationToken.None);
            cloudMailToken = token;
            Snackbar.Add("Token 已生成并填入（记得点击“保存配置”）", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"生成 Token 失败：{ex.Message}", Severity.Error);
        }
        finally
        {
            cloudMailGeneratingToken = false;
        }
    }

    private async Task SaveBotAutoSyncConfig()
    {
        if (botAutoSyncEnabled && (botAutoSyncIntervalSeconds < 2 || botAutoSyncIntervalSeconds > 60))
        {
            Snackbar.Add("Bot 自动同步轮询间隔范围应为 2-60 秒", Severity.Error);
            return;
        }

        try
        {
            var root = await LoadOrCreateLocalConfigAsync();
            var tg = EnsureObject(root, "Telegram");
            tg["BotAutoSyncEnabled"] = botAutoSyncEnabled;
            tg["BotAutoSyncIntervalSeconds"] = botAutoSyncIntervalSeconds;
            await SaveLocalConfigAsync(root);

            Snackbar.Add("Bot 自动同步设置已保存（重启/自动重载后生效）", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"保存失败：{ex.Message}（路径：{LocalConfigPath}）", Severity.Error);
        }
    }

    private async Task SaveTimeZoneConfig()
    {
        try
        {
            var id = (timeZoneId ?? string.Empty).Trim();
            var root = await LoadOrCreateLocalConfigAsync();
            var system = EnsureObject(root, "System");
            system["TimeZoneId"] = id;
            await SaveLocalConfigAsync(root);

            Snackbar.Add("时区设置已保存（配置热重载后生效）", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"保存失败：{ex.Message}（路径：{LocalConfigPath}）", Severity.Error);
        }
    }

    private Task OpenChangePassword()
    {
        Navigation.NavigateTo("/admin/password");
        return Task.CompletedTask;
    }

    private async Task<System.Text.Json.Nodes.JsonObject> LoadOrCreateLocalConfigAsync()
    {
        var path = LocalConfigPath;
        if (!System.IO.File.Exists(path))
            return new System.Text.Json.Nodes.JsonObject();

        var json = await System.IO.File.ReadAllTextAsync(path);
        if (string.IsNullOrWhiteSpace(json))
            return new System.Text.Json.Nodes.JsonObject();

        return System.Text.Json.Nodes.JsonNode.Parse(json)?.AsObject()
               ?? new System.Text.Json.Nodes.JsonObject();
    }

    private async Task SaveLocalConfigAsync(System.Text.Json.Nodes.JsonObject root)
    {
        var json = root.ToJsonString(new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
        var path = LocalConfigPath;
        await LocalConfigFile.EnsureExistsAsync(path);
        await LocalConfigFile.WriteJsonAtomicallyAsync(path, json);
    }

    private static System.Text.Json.Nodes.JsonObject EnsureObject(System.Text.Json.Nodes.JsonObject root, string key)
    {
        if (root[key] is System.Text.Json.Nodes.JsonObject obj)
            return obj;

        var created = new System.Text.Json.Nodes.JsonObject();
        root[key] = created;
        return created;
    }

    private Task SaveBatchConfig()
    {
        // TODO: 实现配置保存到文件
        Snackbar.Add("批量操作配置已保存", Severity.Success);
        return Task.CompletedTask;
    }

    private Task SaveLogConfig()
    {
        return SaveLogConfigAsync();
    }

    private async Task SaveLogConfigAsync()
    {
        var level = (logLevel ?? "Information").Trim();
        if (level is not ("Debug" or "Information" or "Warning" or "Error"))
        {
            Snackbar.Add("日志级别无效", Severity.Error);
            return;
        }

        if (logRetentionDays < 1 || logRetentionDays > 90)
        {
            Snackbar.Add("日志保留天数范围应为 1-90", Severity.Error);
            return;
        }

        try
        {
            var root = await LoadOrCreateLocalConfigAsync();
            var serilog = EnsureObject(root, "Serilog");
            serilog["Enabled"] = logEnabled;

            var minimumLevel = EnsureObject(serilog, "MinimumLevel");
            minimumLevel["Default"] = level;

            // 程序使用按天滚动的日志文件，因此“保留天数”可以映射到“保留文件数”。
            serilog["RetainedFileCountLimit"] = logRetentionDays;

            await SaveLocalConfigAsync(root);
            Snackbar.Add("日志配置已保存（重启后生效）", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"保存失败：{ex.Message}（路径：{LocalConfigPath}）", Severity.Error);
        }
    }

    private async Task SyncNow()
    {
        if (syncing)
        {
            Snackbar.Add("正在同步中，请稍候...", Severity.Warning);
            return;
        }

        syncing = true;
        Snackbar.Add("开始同步频道和群组信息...", Severity.Info);

        try
        {
            var summary = await DataSync.SyncAllActiveAccountsAsync(CancellationToken.None);

            foreach (var failure in summary.AccountFailures)
                Snackbar.Add($"账号 {failure.Phone} 同步失败：{failure.Error}", Severity.Warning);

            Snackbar.Add($"同步完成：{summary.TotalChannelsSynced} 个频道，{summary.TotalGroupsSynced} 个群组", summary.AccountFailures.Count == 0 ? Severity.Success : Severity.Warning);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"同步失败：{ex.Message}", Severity.Error);
        }
        finally
        {
            syncing = false;
        }
    }

    private async Task ClearCache()
    {
        bool? result = await DialogService.ShowMessageBox(
            "确认清除",
            "确定要清除缓存吗？这将清除所有临时数据。",
            yesText: "清除", cancelText: "取消");

        if (result == true)
        {
            // TODO: 实现缓存清除逻辑
            Snackbar.Add("缓存已清除", Severity.Success);
        }
    }
}
