@page "/settings"
@inject IConfiguration Configuration
@inject AccountManagementService AccountManagement
@inject ChannelManagementService ChannelManagement
@inject GroupManagementService GroupManagement
@inject IChannelService ChannelService
@inject IGroupService GroupService
@inject ITelegramClientPool TelegramClientPool
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IWebHostEnvironment Environment

<PageTitle>系统设置 - Telegram Panel</PageTitle>

<MudText Typo="Typo.h4" Class="mb-4">系统设置</MudText>

<MudGrid>
    <MudItem xs="12" md="6">
        <MudCard Class="mb-4">
            <MudCardHeader>
                <MudText Typo="Typo.h6">Telegram API 配置</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudTextField @bind-Value="apiId" Label="默认 API ID" Variant="Variant.Outlined"
                              HelperText="从 https://my.telegram.org 获取" />
                <MudTextField @bind-Value="apiHash" Label="默认 API Hash" Variant="Variant.Outlined" Class="mt-3"
                              HelperText="用于新账号登录和导入" />
                <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Dense="true" Class="mt-3">
                    <MudText Typo="Typo.body2"><strong>写入位置：</strong>@LocalConfigPath</MudText>
                    <MudText Typo="Typo.body2" Class="mt-1"><strong>文件存在：</strong>@(LocalConfigExists ? "是" : "否")</MudText>
                    <MudText Typo="Typo.body2" Class="mt-1"><strong>当前生效 ApiId：</strong>@(Configuration["Telegram:ApiId"] ?? "（未配置）")</MudText>
                </MudAlert>
            </MudCardContent>
            <MudCardActions>
                <MudButton Variant="Variant.Filled" Color="Color.Primary"
                           OnClick="@(async (MouseEventArgs _) => await SaveApiConfig())">
                    保存配置
                </MudButton>
            </MudCardActions>
        </MudCard>

        <MudCard>
            <MudCardHeader>
                <MudText Typo="Typo.h6">批量操作设置</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudNumericField @bind-Value="defaultDelay" Label="默认操作间隔 (毫秒)" Variant="Variant.Outlined"
                                 Min="1000" Max="10000" HelperText="建议2000-5000ms" />
                <MudNumericField @bind-Value="maxConcurrent" Label="最大并发任务数" Variant="Variant.Outlined" Class="mt-3"
                                 Min="1" Max="10" HelperText="同时执行的任务数量" />
                <MudSwitch @bind-Value="autoRetry" Label="失败自动重试" Color="Color.Primary" Class="mt-3" />
                @if (autoRetry)
                {
                    <MudNumericField @bind-Value="maxRetries" Label="最大重试次数" Variant="Variant.Outlined" Class="mt-3"
                                     Min="1" Max="5" />
                }
            </MudCardContent>
            <MudCardActions>
                <MudButton Variant="Variant.Filled" Color="Color.Primary"
                           OnClick="@(async (MouseEventArgs _) => await SaveBatchConfig())">
                    保存配置
                </MudButton>
            </MudCardActions>
        </MudCard>
    </MudItem>

    <MudItem xs="12" md="6">
        <MudCard Class="mb-4">
            <MudCardHeader>
                <MudText Typo="Typo.h6">数据同步</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudSwitch @bind-Value="autoSync" Label="自动同步频道/群组信息" Color="Color.Primary" />
                @if (autoSync)
                {
                    <MudNumericField @bind-Value="syncInterval" Label="同步间隔 (小时)" Variant="Variant.Outlined" Class="mt-3"
                                     Min="1" Max="24" />
                }
                <MudButton Variant="Variant.Outlined" Color="Color.Info" FullWidth="true" Class="mt-4"
                           OnClick="@(async (MouseEventArgs _) => await SyncNow())">
                    立即同步
                </MudButton>
            </MudCardContent>
        </MudCard>

        <MudCard Class="mb-4">
            <MudCardHeader>
                <MudText Typo="Typo.h6">日志设置</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudSelect @bind-Value="logLevel" Label="日志级别" Variant="Variant.Outlined">
                    <MudSelectItem Value='@("Debug")'>Debug</MudSelectItem>
                    <MudSelectItem Value='@("Information")'>Information</MudSelectItem>
                    <MudSelectItem Value='@("Warning")'>Warning</MudSelectItem>
                    <MudSelectItem Value='@("Error")'>Error</MudSelectItem>
                </MudSelect>
                <MudNumericField @bind-Value="logRetentionDays" Label="日志保留天数" Variant="Variant.Outlined" Class="mt-3"
                                 Min="1" Max="90" />
            </MudCardContent>
            <MudCardActions>
                <MudButton Variant="Variant.Filled" Color="Color.Primary"
                           OnClick="@(async (MouseEventArgs _) => await SaveLogConfig())">
                    保存配置
                </MudButton>
            </MudCardActions>
        </MudCard>

        <MudCard>
            <MudCardHeader>
                <MudText Typo="Typo.h6">系统信息</MudText>
            </MudCardHeader>
            <MudCardContent>
                <MudText Typo="Typo.body2"><strong>版本：</strong> 1.0.0</MudText>
                <MudText Typo="Typo.body2" Class="mt-2"><strong>运行时：</strong> .NET 8.0</MudText>
                <MudText Typo="Typo.body2" Class="mt-2"><strong>数据库：</strong> SQLite</MudText>
                <MudDivider Class="my-3" />
                <MudButton Variant="Variant.Outlined" Color="Color.Secondary" FullWidth="true"
                           StartIcon="@Icons.Material.Filled.Delete"
                           OnClick="@(async (MouseEventArgs _) => await ClearCache())">
                    清除缓存
                </MudButton>
            </MudCardContent>
        </MudCard>
    </MudItem>
</MudGrid>

@code {
    private string apiId = "";
    private string apiHash = "";
    private int defaultDelay = 2000;
    private int maxConcurrent = 3;
    private bool autoRetry = true;
    private int maxRetries = 3;
    private bool autoSync = true;
    private int syncInterval = 6;
    private string logLevel = "Information";
    private int logRetentionDays = 30;
    private bool syncing = false;

    private string LocalConfigPath => System.IO.Path.Combine(Environment.ContentRootPath, "appsettings.local.json");
    private bool LocalConfigExists => System.IO.File.Exists(LocalConfigPath);

    protected override void OnInitialized()
    {
        // 从配置文件加载默认设置
        apiId = Configuration["Telegram:ApiId"] ?? "";
        apiHash = Configuration["Telegram:ApiHash"] ?? "";
    }

    private async Task SaveApiConfig()
    {
        if (!int.TryParse(apiId, out int parsedApiId) || parsedApiId <= 0)
        {
            Snackbar.Add("默认 API ID 格式错误", Severity.Error);
            return;
        }

        if (string.IsNullOrWhiteSpace(apiHash))
        {
            Snackbar.Add("默认 API Hash 不能为空", Severity.Error);
            return;
        }

        var localSettings = new
        {
            Telegram = new
            {
                ApiId = parsedApiId,
                ApiHash = apiHash.Trim()
            }
        };

        try
        {
            var localConfigPath = LocalConfigPath;
            var json = System.Text.Json.JsonSerializer.Serialize(
                localSettings,
                new System.Text.Json.JsonSerializerOptions { WriteIndented = true }
            );

            await System.IO.File.WriteAllTextAsync(
                localConfigPath,
                json,
                new System.Text.UTF8Encoding(encoderShouldEmitUTF8Identifier: false)
            );

            // 配置变更后清理客户端缓存，确保后续操作使用新 ApiId/ApiHash
            await TelegramClientPool.RemoveAllClientsAsync();

            var fileInfo = new System.IO.FileInfo(localConfigPath);
            Snackbar.Add($"API 配置已保存：{localConfigPath}（{fileInfo.Length} bytes）。已清理 Telegram 客户端缓存，后续操作将使用新配置。", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"保存失败：{ex.Message}（路径：{LocalConfigPath}）", Severity.Error);
        }
    }

    private Task SaveBatchConfig()
    {
        // TODO: 实现配置保存到文件
        Snackbar.Add("批量操作配置已保存", Severity.Success);
        return Task.CompletedTask;
    }

    private Task SaveLogConfig()
    {
        // TODO: 实现配置保存到文件
        Snackbar.Add("日志配置已保存", Severity.Success);
        return Task.CompletedTask;
    }

    private async Task SyncNow()
    {
        if (syncing)
        {
            Snackbar.Add("正在同步中，请稍候...", Severity.Warning);
            return;
        }

        syncing = true;
        Snackbar.Add("开始同步频道和群组信息...", Severity.Info);

        try
        {
            var accounts = await AccountManagement.GetActiveAccountsAsync();
            int totalChannelsSynced = 0;
            int totalGroupsSynced = 0;

            foreach (var account in accounts)
            {
                try
                {
                    // 同步频道
                    var channels = await ChannelService.GetOwnedChannelsAsync(account.Id);
                    foreach (var channelInfo in channels)
                    {
                        var channel = new Data.Entities.Channel
                        {
                            TelegramId = channelInfo.TelegramId,
                            AccessHash = channelInfo.AccessHash,
                            Title = channelInfo.Title,
                            Username = channelInfo.Username,
                            IsBroadcast = channelInfo.IsBroadcast,
                            MemberCount = channelInfo.MemberCount,
                            About = channelInfo.About,
                            CreatorAccountId = account.Id,
                            CreatedAt = channelInfo.CreatedAt
                        };
                        await ChannelManagement.CreateOrUpdateChannelAsync(channel);
                        totalChannelsSynced++;
                    }

                    // 同步群组
                    var groups = await GroupService.GetOwnedGroupsAsync(account.Id);
                    foreach (var groupInfo in groups)
                    {
                        var group = new Data.Entities.Group
                        {
                            TelegramId = groupInfo.TelegramId,
                            AccessHash = groupInfo.AccessHash,
                            Title = groupInfo.Title,
                            Username = groupInfo.Username,
                            MemberCount = groupInfo.MemberCount,
                            About = null,
                            CreatorAccountId = account.Id
                        };
                        await GroupManagement.CreateOrUpdateGroupAsync(group);
                        totalGroupsSynced++;
                    }

                    // 更新账号的最后同步时间
                    await AccountManagement.UpdateLastSyncTimeAsync(account.Id);
                }
                catch (Exception ex)
                {
                    Snackbar.Add($"账号 {account.Phone} 同步失败：{ex.Message}", Severity.Warning);
                }
            }

            Snackbar.Add($"同步完成：{totalChannelsSynced} 个频道，{totalGroupsSynced} 个群组", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"同步失败：{ex.Message}", Severity.Error);
        }
        finally
        {
            syncing = false;
        }
    }

    private async Task ClearCache()
    {
        bool? result = await DialogService.ShowMessageBox(
            "确认清除",
            "确定要清除缓存吗？这将清除所有临时数据。",
            yesText: "清除", cancelText: "取消");

        if (result == true)
        {
            // TODO: 实现缓存清除逻辑
            Snackbar.Add("缓存已清除", Severity.Success);
        }
    }
}
